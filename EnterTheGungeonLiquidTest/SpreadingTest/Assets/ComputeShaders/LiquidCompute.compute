// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Update
#pragma kernel Diffuse
#pragma kernel ClearAge

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

RWTexture2D<float4> liquidRenderTexture;
RWTexture2D<float4> obstacleRenderTexture;

float2 resolution;

float dt;

float diffuseSpeed = 1;
float expandSpeed = 1;

float stopSpreadingLifetime = 0.5f;
float viewLifetime = 0;

//R -> Liquid quantity
//G -> Liquid type
//B -> Liquid lifetime
//A -> ---------------

[numthreads(8,8,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    float4 finalColor = Result[id.xy];

    //Make Obstacles be always black
    if(distance(float4(0,0,0,0), obstacleRenderTexture[id.xy])>0)
    {
        Result[id.xy] = float4(0,0,0,0);
        return;
    }

    
    finalColor += float4(liquidRenderTexture[id.xy].r,0,0,0); // add The value of the emitter rendered on the liquid Render texture to our finalColor so that the sephere always emits

    float4 neighboursColor = float4(0,0,0,0);
    float neighboursCount =0;
    for(int i =-1; i<2; i++)
    {
        for(int j =-1; j<2; j++)//Loop all the direct neighbours so that the liquid will expand to the neighbour pixels
        {
            if(i == 0 && j == 0)continue;
            if(Result[id.xy + float2(i,j)].b >= stopSpreadingLifetime) continue;// Do not spread if you have more life than 0.5f
                
            neighboursColor += float4(Result[id.xy + float2(i,j)].r,0,0,0) * dt * expandSpeed;
            neighboursCount++;
        } 
    }
    
    finalColor += neighboursColor/clamp(neighboursCount,0.01,1);//avoid divison by 0 when no neighbour is young
    finalColor.b += dt * saturate(finalColor.r * 10000);
    
    Result[id.xy] = finalColor * float4(1, 0,viewLifetime,0);
}

[numthreads(8,8,1)]
void Diffuse (uint3 id : SV_DispatchThreadID)
{
    //if(Result[id.xy].a >= 1)
    //{
    //    Result[id.xy] -=  dt * diffuseSpeed;
    //    if(Result[id.xy].r <= 0) Result[id.xy] = float4(Result[id.xy].r, Result[id.xy].g,Result[id.xy].b,0) ;
    //}
}

[numthreads(8,8,1)]
void ClearAge (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = float4(0, 0,0,0);
}
